<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bytesrw_utf (docs.findlib-1.bytesrw.Bytesrw_utf)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">bytesrw</a> &#x00BB; Bytesrw_utf</nav><header class="odoc-preamble"><h1>Module <code><span>Bytesrw_utf</span></code></h1><p>UTF streams.</p><p>A few tools to deal with UTF encoded streams. For now just encoding guessing, more may be added in the future.</p><p>Sample code for decoding UTF-8 with position tracking using a byte stream reader and encoding UTF-8 with a byte stream writer can be found <a href="https://github.com/dbuenzli/bytesrw/blob/main/test/utf8codec.ml">here</a>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#encodings">Encodings</a></li><li><a href="#encoding_guess">Encoding guess</a></li><li><a href="#encoding_guess_heuristic">Encoding guess heurisitic</a></li></ul></nav></div><div class="odoc-content"><h2 id="encodings"><a href="#encodings" class="anchor"></a>Encodings</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Encoding"><a href="#module-Encoding" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Encoding/index.html">Encoding</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Encoding specification.</p></div></div><h2 id="encoding_guess"><a href="#encoding_guess" class="anchor"></a>Encoding guess</h2><div class="odoc-spec"><div class="spec value anchored" id="val-guess_reader_encoding"><a href="#val-guess_reader_encoding" class="anchor"></a><code><span><span class="keyword">val</span> guess_reader_encoding : <span><a href="../Bytesrw/Bytes/Reader/index.html#type-t">Bytesrw.Bytes.Reader.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Encoding/index.html#type-t">Encoding.t</a></span></code></div><div class="spec-doc"><p><code>guess_reader_encoding r</code> guesses the encoding at the stream position of <code>r</code> by <a href="../Bytesrw/Bytes/Reader/index.html#val-sniff" title="Bytesrw.Bytes.Reader.sniff">sniff</a>ing three bytes and applying <a href="#encoding_guess_heuristic" title="encoding_guess_heuristic">this heuristic</a> which is subject to change in the future.</p></div></div><h2 id="encoding_guess_heuristic"><a href="#encoding_guess_heuristic" class="anchor"></a>Encoding guess heurisitic</h2><p>The heuristic is compatible with <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a> based recognition and the <a href="http://tools.ietf.org/html/rfc4627#section-3">old</a> JSON encoding recognition (UTF-8 is mandated nowadays) that relies on ASCII being present at the beginning of the stream.</p><p>The heuristic looks at the first three bytes of input (or less if impossible) and takes the <em>first</em> matching byte pattern in the table below.</p><pre>xx = any byte
.. = any byte or no byte (input too small)
pp = positive byte
uu = valid UTF-8 first byte

Bytes    | Guess     | Rationale
---------+-----------+-----------------------------------------------
EF BB BF | `UTF_8    | UTF-8 BOM
FE FF .. | `UTF_16BE | UTF-16BE BOM
FF FE .. | `UTF_16LE | UTF-16LE BOM
00 pp .. | `UTF_16BE | ASCII UTF-16BE and U+0000 is often forbidden
pp 00 .. | `UTF_16LE | ASCII UTF-16LE and U+0000 is often forbidden
uu .. .. | `UTF_8    | ASCII UTF-8 or valid UTF-8 first byte.
xx xx .. | `UTF_16BE | Not UTF-8 =&gt; UTF-16, no BOM =&gt; UTF-16BE
.. .. .. | `UTF_8    | Single malformed UTF-8 byte or no input.</pre></div></body></html>
