<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Slice (docs.findlib-1.bytesrw.Bytesrw.Bytes.Slice)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../index.html">Index</a> &#x00BB; <a href="../../../../../index.html">docs</a> &#x00BB; <a href="../../../../index.html">findlib-1</a> &#x00BB; <a href="../../../index.html">bytesrw</a> &#x00BB; <a href="../../index.html">Bytesrw</a> &#x00BB; <a href="../index.html">Bytes</a> &#x00BB; Slice</nav><header class="odoc-preamble"><h1>Module <code><span>Bytes.Slice</span></code></h1><p>Byte slices.</p><p>A byte slice is a <em>non-empty</em> consecutive range of bytes in a <a href="../index.html#type-t"><code>Bytes.t</code></a> value. The unique, distinguished, <em>empty</em> slice <a href="#val-eod"><code>Slice.eod</code></a> is used to indicate end of data.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#validity">Validity</a></li><li><a href="#slice">Slice lengths</a></li><li><a href="#slices">Slices</a></li><li><a href="#end_of_data">End of data</a></li><li><a href="#predicates">Predicates and comparisons</a></li><li><a href="#breaking">Breaking slices</a></li><li><a href="#converting">Converting</a></li><li><a href="#format">Formatting and inspecting</a></li></ul></nav></div><div class="odoc-content"><h2 id="validity"><a href="#validity" class="anchor"></a>Validity</h2><p>The bytes in the range of a slice is made available to a third-party for a limited amount of time during which the slice is said to be <em>valid</em> for reading or writing (or both). Third parties are only allowed to access the bytes in the range and in the mode specified while it is valid.</p><h2 id="slice"><a href="#slice" class="anchor"></a>Slice lengths</h2><div class="odoc-spec"><div class="spec type anchored" id="type-length"><a href="#type-length" class="anchor"></a><code><span><span class="keyword">type</span> length</span><span> = int</span></code></div><div class="spec-doc"><p>The type for slice lengths. A <em>positive</em> integer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-default_length"><a href="#val-default_length" class="anchor"></a><code><span><span class="keyword">val</span> default_length : <a href="#type-length">length</a></span></code></div><div class="spec-doc"><p><code>default_length</code> is <a href="#val-io_buffer_size"><code>io_buffer_size</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-io_buffer_size"><a href="#val-io_buffer_size" class="anchor"></a><code><span><span class="keyword">val</span> io_buffer_size : <a href="#type-length">length</a></span></code></div><div class="spec-doc"><p><code>io_buffer_size</code> is <code>65536</code> it should correspond to the value of OCaml's IO_BUFFER_SIZE. See <a href="https://github.com/ocaml/ocaml/issues/5938">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unix_io_buffer_size"><a href="#val-unix_io_buffer_size" class="anchor"></a><code><span><span class="keyword">val</span> unix_io_buffer_size : <a href="#type-length">length</a></span></code></div><div class="spec-doc"><p><code>unix_io_buffer_size</code> is <code>65536</code> it should correspond to the value of OCaml's UNIX_BUFFER_SIZE. See <a href="https://github.com/ocaml/ocaml/issues/5938">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_length"><a href="#val-check_length" class="anchor"></a><code><span><span class="keyword">val</span> check_length : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-length">length</a></span></code></div><div class="spec-doc"><p><code>check_length l</code> is <code>l</code> if <code>l &gt; 0</code> and raises <code>Invalid_argument</code> otherwise.</p></div></div><h2 id="slices"><a href="#slices" class="anchor"></a>Slices</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for byte slices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span><span class="label">first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">length</span>:<a href="#type-length">length</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make b ~first ~length</code> is a slice referencing the bytes of <code>b</code> in the range [<code>first</code>; <code>first+length-1</code>].</p><p>This function does not allow the creation of the empty <a href="#val-eod"><code>Slice.eod</code></a> which is a feature. It raises <code>Invalid_argument</code> if <code>length</code> is not positive, larger than the length of <code>b</code> or if <code>first</code> is out of bounds.</p><p>See also <a href="#val-make_or_eod"><code>make_or_eod</code></a> and <a href="#val-of_bytes"><code>of_bytes</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_or_eod"><a href="#val-make_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> make_or_eod : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span><span class="label">first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">length</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make_or_eod b ~first ~length</code> is like <a href="#val-make"><code>make</code></a> but returns <a href="#val-eod"><code>eod</code></a> instead of raising <code>Invalid_argument</code> if <code>length</code> is zero. <code>first</code> must be a valid position of <code>b</code>, see <a href="../index.html#val-sub"><code>Bytes.sub</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>bytes s</code> are the underlying bytes of the slice <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>first s</code> is the index, in <code>bytes s</code>, of the first byte of the byte range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>last s</code> is the index, in <code>bytes s</code>, of the last byte of the byte range of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length s</code> is the byte length of the byte range of <code>s</code>. This returns <code>0</code> only on <a href="#val-eod"><code>eod</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><span class="label">tight</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy ~tight s</code> is a copy of <code>s</code>. If <code>tight</code> is <code>true</code>, the copy contains only the bytes in the range of <code>s</code>. If not the whole <code>bytes s</code> is copied.</p></div></div><h2 id="end_of_data"><a href="#end_of_data" class="anchor"></a>End of data</h2><div class="odoc-spec"><div class="spec value anchored" id="val-eod"><a href="#val-eod" class="anchor"></a><code><span><span class="keyword">val</span> eod : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>eod</code> is a slice to denote the end of data. It is the only slice with <code>length d = 0</code>. Its bytes are <a href="../index.html#val-empty"><code>Bytes.empty</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_eod"><a href="#val-is_eod" class="anchor"></a><code><span><span class="keyword">val</span> is_eod : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_eod s</code> is <code>true</code> iff <code>s == eod</code>.</p></div></div><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates and comparisons</h2><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal s0 s1</code> is <code>true</code> iff the bytes in the slice ranges of <code>s0</code> and <code>s1</code> are equal.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare s0 s1</code> sorts the bytes in the slice ranges of <code>s0</code> and <code>s1</code> in lexicographic order.</p></div></div><h2 id="breaking"><a href="#breaking" class="anchor"></a>Breaking slices</h2><p><b>Warning.</b> In these operations index specification are in <em>slice space</em> which starts at 0 at the slice's <a href="#val-first"><code>first</code></a> byte.</p><div class="odoc-spec"><div class="spec value anchored" id="val-take"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>take n s</code> is the slice made of the first <code>n</code> bytes starting at <a href="#val-first"><code>first</code></a>. This is <code>None</code> if the operation results in <a href="#val-eod"><code>eod</code></a>, including if <code>s</code> is <a href="#val-eod"><code>eod</code></a> or if <code>n &lt; 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>drop n s</code> is the slice made of the bytes in the range of <code>s</code> without the first <code>n</code> bytes starting at <a href="#val-first"><code>first</code></a>. This is <code>None</code> if the operation results in <a href="#val-eod"><code>eod</code></a>, including if <code>s</code> is <a href="#val-eod"><code>eod</code></a> or if <code>n &lt; 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-break"><a href="#val-break" class="anchor"></a><code><span><span class="keyword">val</span> break : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span> * <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>break n s</code> is <code>(take n s, drop n s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">length</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub s ~first ~length</code> is the slice made of the consecutive bytes of the range <code>b</code> whose indices exist in the non-empty slice space range [<code>first</code>;<code>first + length - 1</code>]. Raises <code>Invalid_argument</code> if the interval is empty or out of bounds. See also <a href="#val-sub_or_eod"><code>sub_or_eod</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_or_eod"><a href="#val-sub_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> sub_or_eod : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">length</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub_or_eod s ~first ~length</code> is like <a href="#val-sub"><code>sub</code></a> except that if the interval is empty, <a href="#val-eod"><code>eod</code></a> is returned. <code>first</code> must be a valid position of <code>s</code>, see <a href="../index.html#val-sub"><code>Bytes.sub</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subrange"><a href="#val-subrange" class="anchor"></a><code><span><span class="keyword">val</span> subrange : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>subrange ~first ~last s</code> is the slice made of the consecutive bytes of the range of <code>s</code> whose indices exist in the non-empty slice space range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and <code>last</code> to <code>Slice.length s - 1</code>. Note that both <code>first</code> and <code>last</code> can be any integer. If <code>s</code> is <a href="#val-eod"><code>eod</code></a> or if <code>first &gt; last</code> the interval is empty and <code>Invalid_argument</code> is raised. See also <a href="#val-subrange_or_eod"><code>subrange_or_eod</code></a> and <a href="#val-make"><code>make</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subrange_or_eod"><a href="#val-subrange_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> subrange_or_eod : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>subrange_or_eod</code> is like <a href="#val-of_bytes"><code>of_bytes</code></a> except that if the bytes are empty or if <code>first &gt; last</code>, <a href="#val-eod"><code>eod</code></a> is returned.</p></div></div><h2 id="converting"><a href="#converting" class="anchor"></a>Converting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bytes ~first ~last b</code> is the slice made of the consecutive bytes of <code>b</code> whose indices exist in the non-empty range [<code>first</code>;<code>last</code>]. The bytes are not copied.</p><p><code>first</code> defaults to <code>0</code> and <code>last</code> to <code>Bytes.length s - 1</code>. Note that both <code>first</code> and <code>last</code> can be any integer. If <code>b</code> is empty or if <code>first &gt; last</code> the interval is empty and <code>Invalid_argument</code> is raised. See also <a href="#val-of_bytes_or_eod"><code>of_bytes_or_eod</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes_or_eod"><a href="#val-of_bytes_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes_or_eod : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bytes_or_eod</code> is like <a href="#val-of_bytes"><code>of_bytes</code></a> except that if the bytes are empty or if <code>first &gt; last</code>, <a href="#val-eod"><code>eod</code></a> is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bigbytes"><a href="#val-of_bigbytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bigbytes : 
  <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(int, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bigbytes</code> is like <a href="#val-of_bytes"><code>of_bytes</code></a> but <b>copies</b> data from a bigbytes value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bigbytes_or_eod"><a href="#val-of_bigbytes_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> of_bigbytes_or_eod : 
  <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(int, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bytes_or_eod</code> is like <a href="#val-of_bytes_or_eod"><code>of_bytes_or_eod</code></a> but <b>copies</b> data from a bigbytes value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string s</code> is <code>of_bytes (Bytes.of_string s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string_or_eod"><a href="#val-of_string_or_eod" class="anchor"></a><code><span><span class="keyword">val</span> of_string_or_eod : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string_or_eod</code> is <code>of_bytes_or_eod (Bytes.of_string s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>to_bytes t</code> copies the range of <code>s</code> to a new <code>bytes</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bigbytes"><a href="#val-to_bigbytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bigbytes : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div><div class="spec-doc"><p><code>to_bigbytes t</code> copies the range of <code>s</code> to a new bigbytes value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string s</code> copies the range of <code>s</code> to a new <code>string</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_to_buffer"><a href="#val-add_to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> add_to_buffer : <span><a href="../../../../../stdlib/Stdlib/Buffer/index.html#type-t">Buffer.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_to_buffer b s</code> adds the byte range of <code>s</code> to <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_to_out_channel"><a href="#val-output_to_out_channel" class="anchor"></a><code><span><span class="keyword">val</span> output_to_out_channel : <span><a href="../../../../../stdlib/Stdlib/Out_channel/index.html#type-t">Out_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_to_out_channel oc s</code> outputs the byte range of <code>s</code> to <code>oc</code>. <b>Warning.</b> Make sure the channel is in <a href="../../../../../stdlib/Stdlib/Out_channel/index.html#val-set_binary_mode" title="Out_channel.set_binary_mode">binary mode</a>. For example by default <code>stdout</code> is not.</p></div></div><h2 id="format"><a href="#format" class="anchor"></a>Formatting and inspecting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../../../../stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp</code> formats a slice for inspection. This formats the range specification and at most the first four bytes of the buffer in hex.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp'"><a href="#val-pp'" class="anchor"></a><code><span><span class="keyword">val</span> pp' : <span><span class="optlabel">?head</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?hex</span>:bool <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp'</code> is like <a href="#val-pp"><code>pp</code></a> but prints raw bytes if <code>hex</code> is <code>false</code> (defaults to <code>true</code>) and prints at most <code>head</code> initial bytes (defaults to <code>4</code>, use (-1) to format all the bytes).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tracer"><a href="#val-tracer" class="anchor"></a><code><span><span class="keyword">val</span> tracer : 
  <span><span class="optlabel">?pp</span>:<span>(<span><a href="../../../../../stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?ppf</span>:<a href="../../../../../stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>tracer ~pp ~ppf ~id</code> is a function that formats slices on <code>ppf</code> (defaults to <a href="../../../../../stdlib/Stdlib/Format/index.html#val-err_formatter"><code>Format.err_formatter</code></a>) with <code>pp</code> (defaults to <a href="#val-pp"><code>pp</code></a>) and the identifier <code>id</code>. Use with <a href="../Reader/index.html#val-tap"><code>Reader.tap</code></a> or <a href="../Writer/index.html#val-tap"><code>Writer.tap</code></a>.</p></div></div></div></body></html>
