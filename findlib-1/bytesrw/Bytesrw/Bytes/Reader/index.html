<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Reader (docs.findlib-1.bytesrw.Bytesrw.Bytes.Reader)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../index.html">Index</a> &#x00BB; <a href="../../../../../index.html">docs</a> &#x00BB; <a href="../../../../index.html">findlib-1</a> &#x00BB; <a href="../../../index.html">bytesrw</a> &#x00BB; <a href="../../index.html">Bytesrw</a> &#x00BB; <a href="../index.html">Bytes</a> &#x00BB; Reader</nav><header class="odoc-preamble"><h1>Module <code><span>Bytes.Reader</span></code></h1><p>Byte stream readers.</p><p>Byte streams are sequences of non-empty <a href="../Slice/index.html" title="Slice">byte slices</a> ended by a single <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> slice. A byte stream reader provides read access to these slices in order, on demand, but only slice by slice: the slice you get is <a href="../Slice/index.html#validity" title="validity">valid for reading</a> only until the next slice is <a href="#val-read" title="Reader.read">read</a> from the reader.</p><p>See the <span class="xref-unresolved" title="index.quick">quick start</span> and read about stream readers in the <span class="xref-unresolved" title="tutorial.readers">tutorial</span>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#readers">Readers</a></li><li><a href="#reads">Reading</a></li><li><a href="#filters">Filters</a></li><li><a href="#append">Appending</a></li><li><a href="#taps">Taps</a></li><li><a href="#predicates">Predicates and comparisons</a></li><li><a href="#convert">Converting</a></li><li><a href="#fmt">Formatting</a></li></ul></nav></div><div class="odoc-content"><h2 id="readers"><a href="#readers" class="anchor"></a>Readers</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for byte stream readers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../Slice/index.html#type-t">Slice.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make read</code> is a reader from the function <code>read</code> which enumerates the slices of a byte stream. The contract between the reader and <code>read</code> is as follows:</p><ul><li>The slice returned by a call to <code>read</code> must remain <a href="../Slice/index.html#validity" title="validity">valid for reading</a> until the next call to <code>read</code>.</li><li>The reader guarantees to dereference <code>read</code> and never call it again as soon as <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> is returned by <code>read</code>.</li></ul><p><code>pos</code> defaults to <code>0</code> and <code>slice_length</code> to <a href="../Slice/index.html#val-default_length"><code>Slice.default_length</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty ()</code> is <code>make (Fun.const Slice.eod)</code>, an empty byte stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pos"><a href="#val-pos" class="anchor"></a><code><span><span class="keyword">val</span> pos : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Stream/index.html#type-pos">Stream.pos</a></span></code></div><div class="spec-doc"><p><code>pos r</code> is the <a href="../Stream/index.html#type-pos" title="Stream.pos">stream position</a> of the next byte to read. Alternatively it can be seen as the number of bytes returned by calls to <code>read</code> (not including <a href="#val-push_back" title="push_back">push back</a> replays), see <a href="#val-read_length"><code>read_length</code></a>.</p><p><b>Warning.</b> Due to <a href="#val-push_back" title="push_back">push backs</a> negative values can be returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_length"><a href="#val-read_length" class="anchor"></a><code><span><span class="keyword">val</span> read_length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>read_length r</code> is an alternative name for <a href="#val-pos"><code>pos</code></a>.</p><p><b>Warning.</b> Due to <a href="#val-push_back" title="push_back">push backs</a> negative values can be returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slice_length"><a href="#val-slice_length" class="anchor"></a><code><span><span class="keyword">val</span> slice_length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Slice/index.html#type-length">Slice.length</a></span></code></div><div class="spec-doc"><p><code>slice_length r</code> is a hint on the maximal length of slices that <code>r</code> returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-error"><a href="#val-error" class="anchor"></a><code><span><span class="keyword">val</span> error : <span><span><span class="type-var">'e</span> <a href="../Stream/index.html#type-format_error">Stream.format_error</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>error fmt r e</code> raises a <a href="../Stream/index.html#exception-Error"><code>Stream.Error</code></a> <code>e</code> of format <code>fmt</code> for <code>r</code>. <code>pos</code> is the position reported for the error, it defaults to <code>r</code>'s <a href="#val-pos"><code>pos</code></a>. If the value is negative it is added to the latter, e.g. using the negated length of the last slice would report an error at the first byte of the last slice.</p></div></div><h2 id="reads"><a href="#reads" class="anchor"></a>Reading</h2><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Slice/index.html#type-t">Slice.t</a></span></code></div><div class="spec-doc"><p><code>read r</code> reads the next slice from <code>r</code>. The slice is only <a href="../Slice/index.html#validity" title="validity">valid for reading</a> until the next call to <code>read</code> on <code>r</code>. Once <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> is returned, <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> is always returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_back"><a href="#val-push_back" class="anchor"></a><code><span><span class="keyword">val</span> push_back : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Slice/index.html#type-t">Slice.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>push_back r s</code> pushes the slice <code>s</code> back on <code>r</code>. If <code>s</code> is <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> this has no effect. Otherwise the stream position is rewinded by <code>Slice.length s</code> and the next <a href="#val-read"><code>read</code></a> on <code>r</code> returns <code>s</code>.</p><p><b>Note.</b> If <code>r</code> is the result of a call to <a href="#val-tap"><code>tap</code></a> the tap function won't see the push backs. Good for your checksums.</p><p><b>Warning.</b> This should not be used as a general lookahead mecanism by stream readers. Codecs should devise their own buffering structures. But it is useful for stream content <a href="#val-sniff" title="sniff">sniffing</a> and breaking streams into substreams at precise positions.</p><p><b>Warning.</b> Currently it is possible to push back beyond the beginning of a stream. It is unclear whether this feature will be kept in the future. Please get in touch if you use that feature.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sniff"><a href="#val-sniff" class="anchor"></a><code><span><span class="keyword">val</span> sniff : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sniff n r</code> sniffs at most <code>n</code> bytes from <code>r</code>. These bytes will still be returned by <a href="#val-read"><code>read</code></a> calls. Less than <code>n</code> bytes are returned if the end of stream is reached before or if <code>n &lt;= 0</code>.</p><p><b>Warning.</b> This uses <a href="#val-push_back"><code>push_back</code></a> and should not be used as a general lookahead mecanism by stream readers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span><span class="keyword">val</span> skip : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>skip n r</code> is skips <em>at most</em> <code>n</code> bytes from <code>r</code>. See also <a href="#val-discard"><code>discard</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-discard"><a href="#val-discard" class="anchor"></a><code><span><span class="keyword">val</span> discard : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>discard r</code> reads and discards slices until <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> is returned. See also <a href="#val-skip"><code>skip</code></a>.</p></div></div><h2 id="filters"><a href="#filters" class="anchor"></a>Filters</h2><p>Read more about filters in the <span class="xref-unresolved" title="tutorial.reader_filters">tutorial</span>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-filter"><a href="#type-filter" class="anchor"></a><code><span><span class="keyword">type</span> filter</span><span> = <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The type for byte stream reader filters.</p><p>Given a reader <code>r</code>, a filter <code>f</code> returns a filtering reader <code>f r</code>, that reads the stream of <code>r</code> and transforms it in some way. The following conventions should be followed for the resulting filtering reader:</p><ul><li>If <code>pos</code> is unspecified, it should default to <code>r</code>'s position only if the reads on the filtering reader are always in the same position space as <code>r</code> (see e.g. <a href="#val-sub"><code>sub</code></a> or <a href="#val-limit"><code>limit</code></a>). Otherwise it should be <code>0</code> (e.g. on decompression filters) or anything else that makes sense for the filter.</li><li>If <code>slice_length</code> is unspecified, it should default to <code>r</code>'s <a href="#val-slice_length"><code>slice_length</code></a> or what makes more sense for the filter's reads.</li><li>If the filter reader does not read all of <code>r</code>'s bytes, it must, after having returned <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>, leave <code>r</code> at the position of the leftover data so that <code>r</code> can be used again to perform non-filtered reads. This can be done by using <a href="#val-push_back"><code>push_back</code></a> on <code>r</code> with the leftover data.</li><li>If your filter is in a module <code>M</code>, then its name should be <code>M.{decode,encode}_reads</code> or another meaningful verb like <code>M.{decompress,compress}_reads</code>, <code>M.{encrypt,decrypt}_reads</code>, etc.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-filter">filter</a></span></code></div><div class="spec-doc"><p><code>sub n r</code> is a reader reading at most <code>n</code> bytes from <code>r</code> before returning <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>. <code>sub</code> satisfies all the <a href="#type-filter"><code>filter</code></a> conventions and is not affected by push backs: reading back a push back on the sub stream does not count towards <code>n</code>. See also <a href="#val-limit"><code>limit</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-limit"><a href="#val-limit" class="anchor"></a><code><span><span class="keyword">val</span> limit : <span><span class="optlabel">?action</span>:<span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-filter">filter</a></span></code></div><div class="spec-doc"><p><code>limit n r</code> is like <a href="#val-sub"><code>sub</code></a> except it invokes <code>action</code> <b>once</b> with the filter reader before returning <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>. The default <code>action</code> raises <a href="../Stream/index.html#extension-Limit"><code>Stream.Limit</code></a> error. See <span class="xref-unresolved" title="cookbook.limiting">an example</span>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_string"><a href="#val-filter_string" class="anchor"></a><code><span><span class="keyword">val</span> filter_string : <span><span><a href="#type-filter">filter</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>filter_string fs s</code> is a convenience function that applies the filters <code>fs</code>, from left to right to the string <code>s</code> it is equivalent to:</p><pre class="language-ocaml"><code>  to_string (List.fold_left (fun r f -&gt; f r) (of_string s) fs)</code></pre><p>See an <span class="xref-unresolved" title="cookbook.string_filtering">example</span>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reslice"><a href="#val-reslice" class="anchor"></a><code><span><span class="keyword">val</span> reslice : <a href="#type-filter">filter</a></span></code></div><div class="spec-doc"><p><code>reslice ?pos ?slice_length r</code> has the data of <code>r</code> but ensures that all slices are of length <code>slice_length</code> (defaults to <a href="#val-slice_length"><code>slice_length</code></a><code> r</code>) except perhaps the last one.</p></div></div><h2 id="append"><a href="#append" class="anchor"></a>Appending</h2><div class="odoc-spec"><div class="spec value anchored" id="val-append"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>append r0 r1</code> reads from <code>r0</code> and then from <code>r1</code>. <code>pos</code> defaults to <code>0</code> and <code>slice_length</code> defaults to the maximal length of <code>r0</code> and <code>r1</code>.</p></div></div><h2 id="taps"><a href="#taps" class="anchor"></a>Taps</h2><div class="odoc-spec"><div class="spec value anchored" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span><span class="keyword">val</span> tap : <span><span>(<span><a href="../Slice/index.html#type-t">Slice.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>tap f r</code> invokes <code>f</code> with the slice read by <code>r</code> before returning them with <a href="#val-read"><code>read</code></a>. Note that <a href="#val-push_back"><code>push_back</code></a>s are not tapped, so this can be used reliably for checksumming the reads of <code>r</code>. See also <a href="../Slice/index.html#val-tracer"><code>Slice.tracer</code></a> and <span class="xref-unresolved" title="cookbook.tracing">an example</span>.</p></div></div><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates and comparisons</h2><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal r0 r1</code> asserts that the bytes of <code>r0</code> are equal to those of <code>r1</code> in bounded space. This may not fully consume the readers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>equal r0 r1</code> sorts the bytes of <code>r0</code> and <code>r1</code> in lexicographic order in bounded space. This may not fully consume the readers.</p></div></div><h2 id="convert"><a href="#convert" class="anchor"></a>Converting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bytes s</code> reads the bytes of <code>b</code> with slices of maximal length <code>slice_length</code> which defaults to <code>Bytes.length s</code>. <code>pos</code> defaults to <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string b</code> is like <a href="#val-of_bytes"><code>of_bytes</code></a> but reads the bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_in_channel"><a href="#val-of_in_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_in_channel : 
  <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../stdlib/Stdlib/In_channel/index.html#type-t">In_channel.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_in_channel ic</code>, sets <code>ic</code> in <a href="../../../../../stdlib/Stdlib/In_channel/index.html#val-set_binary_mode" title="In_channel.set_binary_mode">binary mode</a> and reads the bytes of <code>ic</code> with slices of maximal length <code>slice_length</code> which defaults to <a href="../Slice/index.html#val-io_buffer_size"><code>Slice.io_buffer_size</code></a>. <code>pos</code> default to <a href="../../../../../stdlib/Stdlib/In_channel/index.html#val-pos"><code>In_channel.pos</code></a>. This function and the resulting reader may raise <code>Sys_error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_slice"><a href="#val-of_slice" class="anchor"></a><code><span><span class="keyword">val</span> of_slice : <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Slice/index.html#type-t">Slice.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_slice s</code> reads <code>r</code> with slice of maximal length <code>slice_length</code> which default to <code>Slice.length s</code>. <code>pos</code> defaults to <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_slice_seq"><a href="#val-of_slice_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_slice_seq : 
  <span><span class="optlabel">?pos</span>:<a href="../Stream/index.html#type-pos">Stream.pos</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?slice_length</span>:<a href="../Slice/index.html#type-length">Slice.length</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Slice/index.html#type-t">Slice.t</a> <a href="../../../../../stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_slice_seq seq</code> reads the slices produced by <code>seq</code>. <code>pos</code> defaults to <code>0</code> and <code>slice_length</code> defaults to <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string r</code> reads <code>r</code> until <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> into a string <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_slice_seq"><a href="#val-to_slice_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_slice_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Slice/index.html#type-t">Slice.t</a> <a href="../../../../../stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_slice_seq r</code> reads <code>r</code> until <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a> into a sequence. The latter is not enumerated.</p><p><b>Warning.</b> A slice returned by the sequence is only <a href="../Slice/index.html#validity" title="validity">valid for reading</a> until the next slice is requested from the sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_to_buffer"><a href="#val-add_to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> add_to_buffer : <span><a href="../../../../../stdlib/Stdlib/Buffer/index.html#type-t">Buffer.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_to_buffer b r</code> reads <code>r</code> and adds its slices to <code>b</code> until <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_to_out_channel"><a href="#val-output_to_out_channel" class="anchor"></a><code><span><span class="keyword">val</span> output_to_out_channel : <span><span class="optlabel">?flush_slices</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../stdlib/Stdlib/Out_channel/index.html#type-t">Out_channel.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_to_out_channel oc r</code>, sets <code>oc</code> in <a href="../../../../../stdlib/Stdlib/Out_channel/index.html#val-set_binary_mode" title="Out_channel.set_binary_mode">binary mode</a>, reads <code>r</code> and outputs the slices on <code>oc</code> until <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>. If <code>flush_slices</code> is <code>true</code>, <code>oc</code> is <a href="../../../../../stdlib/Stdlib/Out_channel/index.html#val-flush" title="Out_channel.flush">flushed</a> after each slice except <a href="../Slice/index.html#val-eod"><code>Slice.eod</code></a>. May raise <code>Sys_error</code>.</p></div></div><h2 id="fmt"><a href="#fmt" class="anchor"></a>Formatting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../../../../stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp</code> formats a readers's properties for inspection. It does not consume any input.</p></div></div></div></body></html>
