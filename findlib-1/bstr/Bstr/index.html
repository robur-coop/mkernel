<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bstr (docs.findlib-1.bstr.Bstr)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">bstr</a> &#x00BB; Bstr</nav><header class="odoc-preamble"><h1>Module <code><span>Bstr</span></code></h1><p>A small library for manipulating bigstrings.</p><p>A bigstring is a mutable data structure that contains a fixed-length sequence of bytes. Each byte can be indexed in constant time for reading and writing.</p><p>Given a byte sequence <code>bstr</code> of length <code>len</code>, we can access each of the <code>len</code> bytes of <code>bstr</code> via its index in the sequence. Indexes start at <code>0</code>, and will call an index valid in <code>bstr</code> if it falls within the range <code>[0...len-1]</code> (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in <code>bstr</code> if it falls within the range <code>[0...len]</code> (inclusive). Note that byte at index <code>n</code> is between positions <code>n</code> and <code>n+1</code>.</p><p>Two parameters <code>off</code> and <code>len</code> are said to designate a valid range of <code>bstr</code> if <code>len &gt;= 0</code> and <code>off</code> and <code>off+len</code> are valid positions in <code>bstr</code>.</p><p>Byte sequences can be modified in place, for instance via the <a href="#val-set"><code>set</code></a> and <a href="#val-blit"><code>blit</code></a> functions described below.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#bigarray">Bigstrings &amp; Bigarrays.</a></li><li><a href="#bytes">Bigstrings &amp; Bytes.</a><ul><li><a href="#location">Bigstrings and the Garbage Collector.</a></li><li><a href="#sub">Bigstring and slice.</a></li></ul></li><li><a href="#bigstrings.">Bigstrings.</a><ul><li><a href="#constructors.">Constructors.</a></li><li><a href="#memory-safe-operations.">Memory-safe Operations.</a></li><li><a href="#copy-operation-from-one-byte-sequence-to-another.">Copy operation from one byte sequence to another.</a></li><li><a href="#decode-integers-from-a-byte-sequence.">Decode integers from a byte sequence.</a></li><li><a href="#predicates-and-comparaisons.">Predicates and comparaisons.</a></li><li><a href="#extracting-substrings.">Extracting substrings.</a></li><li><a href="#traversing-strings.">Traversing strings.</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="bigarray"><a href="#bigarray" class="anchor"></a>Bigstrings &amp; Bigarrays.</h2><p>Bigstring is a specialised version of <a href="../../../stdlib/Stdlib/Bigarray/index.html"><code>Bigarray</code></a> that not only handles bytes in the form of <a href="../../../stdlib/Stdlib/Char/index.html"><code>Char</code></a>acter but also imposes a &quot;C-like&quot; (see <a href="../../../stdlib/Stdlib/Bigarray/index.html#val-c_layout"><code>Bigarray.c_layout</code></a>) view as described above and allows common functions such as <code>memcpy(3)</code> or <code>memmove(3)</code> to be offered.</p><p>For more details about Bigstrings and Bigarrays, we invite you to read the <a href="../../../stdlib/Stdlib/Bigarray/index.html"><code>Bigarray</code></a> documentation, which offers more general functions that can be applied to Bigstrings.</p><h2 id="bytes"><a href="#bytes" class="anchor"></a>Bigstrings &amp; Bytes.</h2><p>Like bytes, a bigstring is a mutable data structure that contains a fixed-length sequence of bytes. However, a bigstring has a few special features that can make it more interesting to use than bytes.</p><h3 id="location"><a href="#location" class="anchor"></a>Bigstrings and the Garbage Collector.</h3><p>A bigstring is not allocated in the same way as a standard OCaml value. In fact, the byte sequence that the bigstring refers to is found in the <i>C heap</i> (rather than the OCaml heap). This means that the byte sequence can come from a <code>malloc(3)</code> or a function requesting a particular memory area from the system such as <code>Unix.map_file</code>.</p><p>This particularity has an implication with the GC: the byte sequence is <b>not relocatable</b>. That is to say that during the cycle of the Garbage Collector, this byte sequence does not move — in contrast, a <code>bytes</code> can be moved by the GC (typically, from the minor heap to the major heap).</p><p>Thus, bigstrings have advantages and disadvantages compared to bytes due to this particularity:</p><ul><li>Creating a bigstring can be expensive. Whether it is with <code>malloc(3)</code>/<a href="#val-create"><code>create</code></a> or <code>Unix.map_file</code>, creating a bigstring will always be more expensive than creating bytes with OCaml. For small byte sequences, it is therefore preferable to use bytes.</li><li>Since a bigstring cannot be moved, its position can be shared by <code>Thread</code>s and/or <code>Domain</code>s without interacting with the GC. An example is being able to perform a complex computation in parallel from the bytes of this sequence without <i>blocking</i> the Garbage Collector during this computation.</li></ul><p>Depending on these characteristics, it may be more advantageous to use a bigstring rather than <code>bytes</code>. This basically depends on your usage, and the special features of bigstrings can unlock opportunities to outperform byte calculations or analysis.</p><h3 id="sub"><a href="#sub" class="anchor"></a>Bigstring and slice.</h3><p>Another advantage of bigstrings is that copying is avoided when extracting part of a larger bigstring. This is because the <a href="#val-sub"><code>sub</code></a> function returns a &quot;proxy&quot; of the original bigstring.</p><p>In this respect, and to be very precise, <a href="#val-sub"><code>sub</code></a> avoids copying but the creation of this &quot;proxy&quot; <b>remains</b> costly. In addition, this library is distributed with a new <code>Slice_bstr</code> module. The latter offers a new type whose <code>Slice_bstr.sub</code> function is much less costly than <a href="#val-sub"><code>sub</code></a>.</p><h2 id="bigstrings."><a href="#bigstrings." class="anchor"></a>Bigstrings.</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> =
  <span><span>(char, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div></div><h3 id="constructors."><a href="#constructors." class="anchor"></a>Constructors.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty</code> is an empty bigstring.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create len</code> returns a new byte sequence of length <code>len</code>. The sequence <b>is unitialized</b> and contains arbitrary bytes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make len chr</code> is <a href="#type-t"><code>t</code></a> of length <code>len</code> with each index holding the character <code>chr</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy t</code> returns a new byte sequence that contains the same bytes as the argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>init len fn</code> returns a fresh byte sequence of length <code>len</code>, with character <code>idx</code> initialized to the result of <code>fn idx</code> (in increasing index order).</p></div></div><h3 id="memory-safe-operations."><a href="#memory-safe-operations." class="anchor"></a>Memory-safe Operations.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string str</code> returns a new <a href="#type-t"><code>t</code></a> that contains the contents of the given string <code>str</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>string ~off ~len str</code> is the sub-buffer of <code>str</code> that starts at position <code>off</code> (defaults to <code>0</code>) and stops at position <code>off + len</code> (defaults to <code>String.length str</code>). <code>str</code> is fully-replaced by a fresh allocated <a href="#type-t"><code>t</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>str</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_string"><a href="#val-sub_string" class="anchor"></a><code><span><span class="keyword">val</span> sub_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sub_string bstr ~off ~len</code> returns a string of length <code>len</code> containing the bytes of <code>bstr</code> starting at <code>off</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>t</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string bstr</code> is equivalent to <code>sub_string bstr ~off:0 ~len:(length bstr)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length bstr</code> is the number of bytes in <code>bstr</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get bstr i</code> is the byte of <code>bstr</code>' at index <code>i</code>. This is equivalent to the <code>bstr.{i}</code> notation.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>i</code> is not an index of <code>bstr</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set t i chr</code> modifies <code>t</code> in place, replacing the byte at index <code>i</code> with <code>chr</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>i</code> is not a valid index in <code>t</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsafe_get"><a href="#val-unsafe_get" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>unsafe_get t idx</code> is like <a href="#val-get"><code>get</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsafe_set"><a href="#val-unsafe_set" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set t idx chr</code> is like <a href="#val-set"><code>set</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chop"><a href="#val-chop" class="anchor"></a><code><span><span class="keyword">val</span> chop : <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>chop bstr</code> returns the first element of <code>bstr</code> or the last element if <code>rev = true</code>. If <code>bstr</code> is empty, it returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>concat sep ts</code> concatenates the list of bigstrings <code>ts</code>, inserting the separator string <code>sep</code> between each.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extend"><a href="#val-extend" class="anchor"></a><code><span><span class="keyword">val</span> extend : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extend bstr left right</code> returns a new bigstring that contains the bytes of <code>bstr</code>, with <code>left</code> zero bytes prepended and <code>right</code> zero byte appended to it. If <code>left</code> or <code>right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code>bstr</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the result length is negative</p></li></ul></div></div><h3 id="copy-operation-from-one-byte-sequence-to-another."><a href="#copy-operation-from-one-byte-sequence-to-another." class="anchor"></a>Copy operation from one byte sequence to another.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src ~src_off dst ~dst_off ~len</code> copies <code>len</code> bytes from byte sequence <code>src</code>, starting at index <code>src_off</code>, to byte sequence <code>dst</code>, starting at index <code>dst_off</code>. It works correctly even if <code>src</code> and <code>dst</code> are (physically) the same byte sequence, and the source and destination intervals overlap.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit_from_string"><a href="#val-blit_from_string" class="anchor"></a><code><span><span class="keyword">val</span> blit_from_string : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Just like <a href="#val-blit"><code>blit</code></a>, but with a string as source one.</p><p><b>Note</b>: since it is impossible for <code>src</code> to overlap <code>dst</code>, <a href="#val-memcpy"><code>memcpy</code></a> is used to do the copy.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_pos</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit_from_bytes"><a href="#val-blit_from_bytes" class="anchor"></a><code><span><span class="keyword">val</span> blit_from_bytes : 
  <span>bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Just like <a href="#val-blit"><code>blit</code></a>, but with a bytes as source one.</p><p><b>Note</b>: since it is impossible for <code>src</code> to overlap <code>dst</code>, <a href="#val-memcpy"><code>memcpy</code></a> is used to do the copy.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_pos</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit_to_bytes"><a href="#val-blit_to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> blit_to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit_to_bytes src ~src_off dst ~dst_off ~len</code> copies <code>len</code> bytes from <code>src</code>, starting at index <code>src_off</code>, to byte sequence <code>dst</code>, starting at index <code>dst_off</code>.</p><p><b>Note</b>: since it is impossible for <code>src</code> to overlap <code>dst</code>, <a href="#val-memcpy"><code>memcpy</code></a> is used to do the copy.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memcpy"><a href="#val-memcpy" class="anchor"></a><code><span><span class="keyword">val</span> memcpy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>memcpy src ~src_off dst ~dst_off ~len</code> copies <code>len</code> bytes from <code>src</code> to <code>dst</code>. <code>src</code> <b>must not</b> overlap <code>dst</code>. Use <a href="#val-memmove"><code>memmove</code></a> if <code>src</code> &amp; <code>dst</code> do overlap.</p><p>You can check whether two buffers overlap using <a href="#val-overlap"><code>overlap</code></a>. If this returns <code>None</code>, the two values do not refer to a common memory area — and it is safe to use memcpy.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memcpy_mmaped"><a href="#val-memcpy_mmaped" class="anchor"></a><code><span><span class="keyword">val</span> memcpy_mmaped : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>memcpy_mmaped</code> is like <a href="#val-memcpy"><code>memcpy</code></a> but <code>src</code> and <code>dst</code> can be a <i>mmaped</i> bigarray (from <code>Unix.map_file</code>). In this specific case, copying from one to the other can take some time because it involves reading/writing to disk. The operation can take longer than if the two bigarrays were allocated via <code>malloc()</code>/<a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#val-create"><code>Bigarray.Array1.create</code></a>.</p><p>It may therefore be worthwhile to release the GC lock so that this specific operation can be carried out in parallel (in a <code>Thread</code>) without interruption by the GC.</p><p>Note that the bigarrays do not necessarily need to be <i>mmaped</i>. This function also applies to &quot;normal&quot; bigarrays. It may also be worthwhile to use this function if you know that you are copying a large area and would like to do it in parallel (in a <code>Thread</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memmove"><a href="#val-memmove" class="anchor"></a><code><span><span class="keyword">val</span> memmove : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>memmove src ~src_off dst ~dst_off ~len</code> copies <code>len</code> bytes from <code>src</code> to <code>dst</code>. <code>src</code> and <code>dst</code> may overlap: copying takes place as though the bytes in <code>src</code> are first copied into a temporary array that does not overlap <code>src</code> or <code>dst</code>, and the bytes are then copied from the temporary array to <code>dst</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memmove_mmaped"><a href="#val-memmove_mmaped" class="anchor"></a><code><span><span class="keyword">val</span> memmove_mmaped : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>memmove_mmaped</code> is like <a href="#val-memmove"><code>memmove</code></a> but <code>src</code> and <code>dst</code> can be a <i>mmaped</i> bigarray (from <code>Unix.map_file</code>). In this specific case, copying from one to the other can take some time because it involves reading/writing to disk. The operation can take longer than if the two bigarrays were allocated via <code>malloc()</code>/<a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#val-create"><code>Bigarray.Array1.create</code></a>.</p><p>It may therefore be worthwhile to release the GC lock so that this specific operation can be carried out in parallel (in a <code>Thread</code>) without interruption by the GC.</p><p>Note that the bigarrays do not necessarily need to be <i>mmaped</i>. This function also applies to &quot;normal&quot; bigarrays. It may also be worthwhile to use this function if you know that you are copying a large area and would like to do it in parallel (in a <code>Thread</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memcmp"><a href="#val-memcmp" class="anchor"></a><code><span><span class="keyword">val</span> memcmp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>memcmp s1 ~src_off s2 ~dst_off ~len</code> compares the first <code>len</code> bytes of the memory areas <code>s1</code> (starting at <code>src_off</code>) and <code>s2</code> (starting at <code>dst_off</code>).</p><p><code>memcmp</code> returns <code>0</code> is <code>s1</code> and <code>s2</code> don't match.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_off</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memset"><a href="#val-memset" class="anchor"></a><code><span><span class="keyword">val</span> memset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>memset t ~off ~len chr</code> fills <code>len</code> bytes (starting at <code>off</code>) into <code>t</code> with the constant byte <code>chr</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>t</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fill t off len chr</code> modifies <code>t</code> in place, replacing <code>len</code> characters with <code>chr</code>, starting at <code>off</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>t</code>.</p></li></ul></div></div><h3 id="decode-integers-from-a-byte-sequence."><a href="#decode-integers-from-a-byte-sequence." class="anchor"></a>Decode integers from a byte sequence.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-get_int8"><a href="#val-get_int8" class="anchor"></a><code><span><span class="keyword">val</span> get_int8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int8 bstr i</code> is <code>bstr</code>'s signed 8-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_uint8"><a href="#val-get_uint8" class="anchor"></a><code><span><span class="keyword">val</span> get_uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_uint8 bstr i</code> is <code>bstr</code>'s unsigned 8-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_uint16_ne"><a href="#val-get_uint16_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_ne bstr i</code> is <code>bstr</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_uint16_le"><a href="#val-get_uint16_le" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_le bstr i</code> is <code>bstr</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_uint16_be"><a href="#val-get_uint16_be" class="anchor"></a><code><span><span class="keyword">val</span> get_uint16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_be bstr i</code> is <code>bstr</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int16_ne"><a href="#val-get_int16_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_ne bstr i</code> is <code>bstr</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int16_le"><a href="#val-get_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_le bstr i</code> is <code>bstr</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int16_be"><a href="#val-get_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_be bstr i</code> is <code>bstr</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int32_ne"><a href="#val-get_int32_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_ne bstr i</code> is <code>bstr</code>'s native-endian 32-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int32_le"><a href="#val-get_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_le bstr i</code> is <code>bstr</code>'s little-endian 32-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int32_be"><a href="#val-get_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_be bstr i</code> is <code>bstr</code>'s big-endian 32-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int64_ne"><a href="#val-get_int64_ne" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_ne bstr i</code> is <code>bstr</code>'s native-endian 64-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int64_le"><a href="#val-get_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_le bstr i</code> is <code>bstr</code>'s little-endian 64-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int64_be"><a href="#val-get_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_be bstr i</code> is <code>bstr</code>'s big-endian 64-bit integer starting at byte index <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int8"><a href="#val-set_int8" class="anchor"></a><code><span><span class="keyword">val</span> set_int8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int8 t i v</code> sets <code>t</code>'s signed 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_uint8"><a href="#val-set_uint8" class="anchor"></a><code><span><span class="keyword">val</span> set_uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint8 t i v</code> sets <code>t</code>'s unsigned 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_uint16_ne"><a href="#val-set_uint16_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_ne t i v</code> sets <code>t</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_uint16_le"><a href="#val-set_uint16_le" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_le t i v</code> sets <code>t</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_uint16_be"><a href="#val-set_uint16_be" class="anchor"></a><code><span><span class="keyword">val</span> set_uint16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_le t i v</code> sets <code>t</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int16_ne"><a href="#val-set_int16_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_ne t i v</code> sets <code>t</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int16_le"><a href="#val-set_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_le t i v</code> sets <code>t</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int16_be"><a href="#val-set_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_uint16_le t i v</code> sets <code>t</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int32_ne"><a href="#val-set_int32_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s native-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int32_le"><a href="#val-set_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s little-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int32_be"><a href="#val-set_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s big-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int64_ne"><a href="#val-set_int64_ne" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s native-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int64_le"><a href="#val-set_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s little-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int64_be"><a href="#val-set_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_ne t i v</code> sets <code>t</code>'s big-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub bstr ~off ~len</code> does not allocate a bigstring, but instead returns a new view into <code>bstr</code> starting at <code>off</code>, and with length <code>len</code>.</p><p><b>Note</b> <code>sub</code> does not allocate a new buffer, but instead shares the memory area of <code>bstr</code> with the newly-returned bigstring. This means that the changes (<code>set{,_*}</code> functions) made to the returned bigstring will also be reflected in the <code>bstr</code> bigstring given.</p><p><b>Note</b> <code>sub</code> is more expensive than a <code>Slice.sub</code> (about 8 times slower). If you want to focus on performance while avoiding copying, it's best to use a <code>Slice</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span><span class="keyword">val</span> shift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>shift bstr n</code> is <code>sub bstr n (length bstr - n)</code> (see <a href="#val-sub"><code>sub</code></a> for more details).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-overlap"><a href="#val-overlap" class="anchor"></a><code><span><span class="keyword">val</span> overlap : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int * int)</span> option</span></span></code></div><div class="spec-doc"><p><code>overlap x y</code> returns the size (in bytes) of what is physically common between <code>x</code> and <code>y</code>, as well as the position of <code>y</code> in <code>x</code> and the position of <code>x</code> in <code>y</code>.</p></div></div><h3 id="predicates-and-comparaisons."><a href="#predicates-and-comparaisons." class="anchor"></a>Predicates and comparaisons.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty bstr</code> is <code>length bstr = 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span><span class="keyword">val</span> is_prefix : <span><span class="label">affix</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_prefix ~affix bstr</code> is <code>true</code> iff <code>affix.[idx] = bstr.{idx}</code> for all indices <code>idx</code> of <code>affix</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-starts_with"><a href="#val-starts_with" class="anchor"></a><code><span><span class="keyword">val</span> starts_with : <span><span class="label">prefix</span>:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>starts_with ~prefix t</code> is like <a href="#val-is_prefix"><code>is_prefix</code></a> but the prefix is a <a href="#type-t"><code>t</code></a> (instead of a <code>string</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_infix"><a href="#val-is_infix" class="anchor"></a><code><span><span class="keyword">val</span> is_infix : <span><span class="label">affix</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_infix ~affix bstr</code> is <code>true</code> iff there exists an index <code>j</code> in <code>bstr</code> such that for all indices <code>i</code> of <code>affix</code> we have <code>affix.[i] = bstr.{j + i}</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_suffix"><a href="#val-is_suffix" class="anchor"></a><code><span><span class="keyword">val</span> is_suffix : <span><span class="label">affix</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_suffix ~affix bstr</code> is <code>true</code> iff <code>affix.[n - idx] = bstr.{m - idx}</code> for all indices <code>idx</code> of <code>affix</code> with <code>n = String.length affix - 1</code> and <code>m = length bstr - 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ends_with"><a href="#val-ends_with" class="anchor"></a><code><span><span class="keyword">val</span> ends_with : <span><span class="label">suffix</span>:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>ends_with ~suffix t</code> is like <a href="#val-is_suffix"><code>is_suffix</code></a> but the suffix is a <a href="#type-t"><code>t</code></a> (instead of a <code>string</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all p bstr</code> is <code>true</code> iff for all indices <code>idx</code> of <code>bstr</code>, <code>p bstr.{idx} = true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains bstr ?off ?len chr</code> is <code>true</code> if and only if <code>chr</code> appears in <code>len</code> byte(s)'s <code>bstr</code> after position <code>off</code> (defaults to <code>0</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> is <code>a = b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-constant_equal"><a href="#val-constant_equal" class="anchor"></a><code><span><span class="keyword">val</span> constant_equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>constant_equal</code> gives the same result as <a href="#val-equal"><code>equal</code></a> but the execution time of the function, whether or not the two values are equivalent (as long as they have the <b>same</b> size) is the same.</p><p>Indeed, the <a href="#val-equal"><code>equal</code></a> function ends as soon as a difference exists. This function continues even if a difference exists. This function is useful when comparing passwords — and avoiding an <i>timing attack</i>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare bstr0 bstr1</code> sorts <code>bstr0</code> and <code>bstr1</code> in lexicographical order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index bstr ?off ?len chr</code> is the index of the first occurrence of <code>chr</code> in <code>len</code> byte(s)'s <code>bstr</code> after position <code>off</code> (defaults to <code>0</code>). If <code>chr</code> does not occur in given range of <code>bstr</code>, we return <code>None</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>bstr</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memchr"><a href="#val-memchr" class="anchor"></a><code><span><span class="keyword">val</span> memchr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>memchr t ~off ~len chr</code> scans <code>len</code> bytes (starting at <code>off</code>) of <code>t</code> for the first instance of <code>chr</code>. It returns the position in <code>t</code> where the first occurrence of <code>chr</code> is found. Otherwise, it returns <code>-1</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>t</code>.</p></li></ul></div></div><h3 id="extracting-substrings."><a href="#extracting-substrings." class="anchor"></a>Extracting substrings.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-with_range"><a href="#val-with_range" class="anchor"></a><code><span><span class="keyword">val</span> with_range : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>with_range ~first ~len bstr</code> are the consecutive bytes of <code>bstr</code> whose indices exist in the range [<code>first</code>;<code>first + len - 1</code>].</p><p><code>first</code> defaults to <code>0</code> and <code>len</code> to <code>max_int</code>. Note that <code>first</code> can be any integer and <code>len</code> any positive integer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_index_range"><a href="#val-with_index_range" class="anchor"></a><code><span><span class="keyword">val</span> with_index_range : <span><span class="optlabel">?first</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?last</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>with_index_range ~first ~last bstr</code> are the consecutive bytes of <code>bstr</code> whose indices exists in the range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and <code>last</code> to <code>length bstr - 1</code>.</p><p>Note that both <code>first</code> and <code>last</code> can be any integer. If <code>first &gt; last</code> the interval is empty and the empty bigstring is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span><span class="optlabel">?drop</span>:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>trim ~drop bstr</code> is <code>bstr</code> with prefix and suffix bytes satisfying <code>drop</code> in <code>bstr</code> removed. <code>drop</code> defaults to <code>fun chr -&gt; chr = ' '</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-span"><a href="#val-span" class="anchor"></a><code><span><span class="keyword">val</span> span : 
  <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?min</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?sat</span>:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>span ~rev ~min ~max ~sat bstr</code> is <code>(l, r)</code> where:</p><ul><li>if <code>rev</code> is <code>false</code> (default), <code>l</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying initial bytes of <code>bstr</code> or <a href="#val-empty"><code>empty</code></a> if there are no such bytes. <code>r</code> are the remaining bytes of <code>bstr</code>.</li><li>if <code>rev</code> is <code>true</code>, <code>r</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying final bytes of <code>bstr</code> or <a href="#val-empty"><code>empty</code></a> if there are no such bytes. <code>l</code> are the remaining bytes of <code>bstr</code>.</li></ul><p>If <code>max</code> is unspecified the span is unlimited. If <code>min</code> is unspecified it defaults to <code>0</code>. If <code>min &gt; max</code> the condition can't be satisfied and the left or right span, depending on <code>rev</code>, is always empty. <code>sat</code> defaults to <code>Fun.const true</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>max</code> or <code>min</code> is negative.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-take"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?min</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?sat</span>:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>take ~rev ~min ~max ~sat bstr</code> is the matching span of <a href="#val-span"><code>span</code></a> without the remaining one. In other words:</p><pre class="language-ocaml"><code>  (if rev then snd else fst) (span ~rev ~min ~max ~sat bstr)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?min</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?max</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?sat</span>:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>drop ~rev ~min ~max ~sat bstr</code> is the remaining span of <a href="#val-span"><code>span</code></a> without the matching span. In other words:</p><pre class="language-ocaml"><code>  (if rev then fst else snd) (span ~rev ~min ~max ~sat bstr)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span><span class="keyword">val</span> cut : <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="label">sep</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>cut ~sep bstr</code> is either the pair <code>Some (l, r)</code> of the two (possibly empty) sub-buffers of <code>bstr</code> that are delimited by the first match of the non empty separator string <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>bstr</code>. Matching starts from the beginning of <code>bstr</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>).</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><p>For instance, the <i>ABNF</i> expression:</p><pre>field_name := *PRINT
field_value := *ASCII
field := field_name &quot;:&quot; field_value</pre><p>can be translated to:</p><pre class="language-ocaml"><code>  match Bstr.cut ~sep:&quot;:&quot; value with
  | Some (field_name, field_value) -&gt; ...
  | None -&gt; invalid_arg &quot;Invalid field&quot;</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>sep</code> is the empty buffer.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cuts"><a href="#val-cuts" class="anchor"></a><code><span><span class="keyword">val</span> cuts : <span><span class="optlabel">?rev</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?empty</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="label">sep</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>cuts sep bstr</code> is the list of all subbigstrings of <code>bstr</code> that are delimited by matches of the non empty separator string <code>sep</code>. Empty subbigstrings are omitted in the list if <code>empty</code> is <code>false</code> (defaults to <code>true</code>).</p><p>Matching separators in <code>bstr</code> starts from the beginning of <code>bstr</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>bstr</code>, the list <code>[bstr]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>equal (concat (of_string sep) (cuts ~empty:true ~sep bstr)) bstr</code></li><li><code>cuts ~empty:true ~sep bstr &lt;&gt; []</code></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>sep</code> is the empty string.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_on_char"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>split_on_char sep t</code> is the list of all (possibly empty) <a href="#val-sub"><code>sub</code></a>-bigstrings of <code>t</code> that are delimited by the character <code>sep</code>. If <code>t</code> is empty, the result is the singleton list <code>[empty]</code>.</p><p>The function's result is specified by the following invariant:</p><ul><li>the list is not empty.</li><li>concatenating its elements using <code>sep</code> as a separator returns a bigstring equal to the input.</li><li>no bigstring in the result contains the <code>sep</code> character.</li></ul></div></div><h3 id="traversing-strings."><a href="#traversing-strings." class="anchor"></a>Traversing strings.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter fn t</code> applies function <code>fn</code> in turn to all the characters of <code>t</code>. It is equivalent to <code>fn t.{0}; fn t.{1}; ...; fn t.{length t - 1}; ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../../../stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the bigstring, in increasing index order. Modifications of the bigstring during iteration will be reflected in the sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seqi"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../../../stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the bigstring, in increasing order, yielding indices along chars.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../../../stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a bigstring from the generator.</p></div></div></div></body></html>
