<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mkernel (docs.local.mkernel.Mkernel)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">local</a> &#x00BB; <a href="../index.html">mkernel</a> &#x00BB; Mkernel</nav><header class="odoc-preamble"><h1>Module <code><span>Mkernel</span></code></h1><p>A simple scheduler for Solo5/Unikraft in OCaml.</p><p>A unikernel is a fully-fledged operating system that essentially wants to be virtualised into a host system such as Linux (KVM) or FreeBSD (Bhyve). In this sense, a unikernel's interactions with the <i>outside world</i> (with other systems) via <i>components</i> are standardised through two types of devices:</p><ul><li>a net interface that emulates an Ethernet port</li><li>a block interface that emulates a hard drive</li></ul><p>These interactions respond to events transmitted by the host system, which retains exclusive direct access to physical components, retrieved by a <i>tender</i> that runs in the host system's user space and is then retransmitted to the unikernel running in its own space.</p><p>The information transmitted between the unikernel and the tender is called a <i>hypercall</i>, and the information transmitted between the tender and the host system is called a <i>syscall</i>. In other words, a <i>hypercall</i> necessarily involves one or more <i>syscalls</i>, and the transmission of the result necessarily passes through the tender (which serves as a bridge between the unikernel and the host system).</p><p>Since these events originate from the <i>outside world</i>, they can occur at any time. It is therefore necessary to be able to manage these events <i>asynchronously</i> so as not to block the reception of a particular event and to be able to do <i>something else</i> while waiting for certain events.</p><p>This library therefore offers two essential features:</p><ul><li>the ability to emit hypercalls as a virtualised unikernel</li><li>the ability to launch and manage tasks asynchronously into our unikernel: in other words, a scheduler</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#scheduler.">Scheduler.</a></li><li><a href="#hypercalls.">Hypercalls.</a><ul><li><a href="#net-interfaces.">Net interfaces.</a><ul><li><a href="#allocating-a-net-device.">Allocating a net device.</a></li></ul></li><li><a href="#block-interfaces.">Block interfaces.</a><ul><li><a href="#allocating-a-block-device.">Allocating a block device.</a></li></ul></li></ul></li><li><a href="#the-first-entry-point-of-an-unikernels.">The first entry-point of an unikernels.</a></li></ul></nav></div><div class="odoc-content"><h3 id="scheduler."><a href="#scheduler." class="anchor"></a>Scheduler.</h3><p>A unikernel has exclusive use of a CPU and a memory area separate from the host system. This CPU simply executes the unikernel code. To date, there is no support for multiple cores. However, a scheduler is certainly needed in order to be able to execute multiple tasks <i>at the same time</i> (cooperatively).</p><p>As such, this library is based on the Miou scheduler. It is a small scheduler that uses the effects of OCaml 5 and allows tasks to be launched and managed asynchronously. Miou's objective is focused on the development of applications that are services (such as a web server). The task management policy is therefore designed so that the unikernel can handle as many hypercalls as possible. This contrasts with a scheduler that would optimise task scheduling in order to complete a calculation as quickly as possible (in other words, a CPU-bound application). Miou is therefore said to be a scheduler for I/O-bound applications.</p><p>For more information about Miou and its task management and API, please read the <a href="https://docs.osau.re/">project documentation</a> and tutorial available <a href="https://robur-coop.github.io/miou/">here</a>.</p><p>In order to launch the Miou scheduler and be able to launch and manage asynchronous tasks, the user must define a first entry point that must necessarily call <a href="#val-run"><code>run</code></a>:</p><pre class="language-ocaml"><code>  let () =
    Mkernel.(run []) @@ fun () -&gt;
    let prm = Miou.async @@ fun () -&gt; print_endline &quot;Hello World!&quot; in
    Mkernel.sleep 1_000_000_000;
    Miou.await_exn prm</code></pre><p>All functions available through the Miou module work when implementing a unikernel <b>except</b> <code>Miou.call</code>, which wants to launch a task in parallel. <code>Miou.call</code> raises an exception because a unikernel only has one CPU.</p><h3 id="hypercalls."><a href="#hypercalls." class="anchor"></a>Hypercalls.</h3><p>Hypercalls are the only way for the unikernel to communicate with the outside world. A hypercall is a signal that we would like to obtain information from a specific external resource (such as a network interface or a block interface). This library offers several functions for emitting these hypercalls, which are then handled by the <i>tender</i> and then by the host system.</p><p>These hypercalls are standardised in a certain way and concern interactions with two types of resources:</p><ul><li>the network interface, which emulates an Ethernet port</li><li>the block interface, which emulates a hard drive</li></ul><h4 id="net-interfaces."><a href="#net-interfaces." class="anchor"></a>Net interfaces.</h4><p>A net interface is a TAP interface connected between your unikernel and the network of your host system. It is through this interface that you can communicate with your system's network and receive packets from it. The TCP/IP stack is also built from this interface.</p><p>The user can read and write packets on such an interface. However, you need to understand how reading and writing behave when developing an application as a unikernel using Solo5/Unikraft.</p><p>Writing a packet to the net interface is <b>direct</b> and failsafe. In other words, we don't need to wait for anything to happen before writing to the net device (if an error occurs on your host system, the tender will fail — and by extension, so will your unikernel). So, from the scheduler's point of view, writing to the net device is atomic and is never suspended by the scheduler in order to have the opportunity to execute other tasks.</p><p>However, this is not the case when reading on the net interface. You might expect to read packets, but they might not be available at the time you try to read them. <code>Mkernel</code> will make a first attempt at reading and if it fails, the scheduler will <i>&quot;suspend&quot;</i> the reading task (and everything that follows from it) to observe at another point in the life of unikernel whether a packet has just arrived.</p><p>Reading on the net interface is currently the only operation where suspension is necessary. In this way, the scheduler can take the opportunity to perform other tasks if reading failed in the first place. It is at the next iteration of the scheduler (after it has executed at least one other task) that <code>Mkernel</code> will ask the tender if a packet has just arrived. If this is the case, the scheduler will resume the reading task, otherwise it will keep it in a suspended state until the next opportunity.</p><h5 id="allocating-a-net-device."><a href="#allocating-a-net-device." class="anchor"></a>Allocating a net device.</h5><p>Whether it is Solo5 (and its tender) or Unikraft (via <code>qemu</code> or <code>firecracker</code>), it is necessary for the user to be able to allocate a network interface, often referred to as a <i>tap</i> interface. The latter is a virtualization of an Ethernet port that can be manipulated both by the unikernel (in order to communicate with the rest of the world) and the host system (to be configured so that the unikernel is connected to a network).</p><p>Here's how to create a tap interface on Linux:</p><pre class="language-ocaml"><code>  $ sudo ip tuntap add name tap0 mode tap
  $ sudo ip link set tap0 up</code></pre><p>It is generally accepted that the tap interface should be connected to a bridge (also virtual) in order to connect multiple unikernels (and therefore multiple tap interfaces) to a network. Here is how to &quot;connect&quot; a tap interface to a bridge:</p><pre class="language-ocaml"><code>  $ sudo ip link add name service type bridge
  $ sudo ip addr add 10.0.0.1/24 dev service
  $ sudo ip link set tap0 master service
  $ sudo ip link set service up</code></pre><p>Finally, it is often accepted that the unikernel can communicate with the Internet. It is generally necessary to configure the host system (its proxy) in order to correctly route incoming/outgoing packets to the unikernel (or your &quot;output&quot;). This last step depends on your network topology, but we recommend learning about iptables, the nat table, and the MASQUERADE target.</p><h4 id="block-interfaces."><a href="#block-interfaces." class="anchor"></a>Block interfaces.</h4><p>Block interfaces are different in that there is no expectation of whether or not there will be data. A block interface can be seen as content to which the user has one access per page (generally 4096 bytes). It can be read and written to. However, the read and write operation can take quite a long time — depending on the file system and your hardware on the host system.</p><p>There are therefore two types of read/write. An atomic read/write and a scheduled read/write.</p><p>An atomic read/write is an operation where you can be sure that it is not divisible (and that something else can be tried) and that the operation is currently being performed. Nothing else can be done until this operation has finished. It should be noted that once the operation has finished, the scheduler does not take the opportunity to do another task. It continues with what needs to be done after the read/write as you have implemented.</p><p>This approach is interesting when you want to have certain invariants (in particular the state of the memory) that other tasks cannot alter despite such an operation. The problem is that this operation can take a considerable amount of time and we can't do anything else at the same time.</p><p>This is why there is the other method, the read/write operation, which is suspended by default and will be performed when the scheduler has the best opportunity to do so — in other words, when it has nothing else to do.</p><p>This type of operation can be interesting when reading/writing does not depend on assumptions and when these operations can be carried out at a later date without the current time at which the operation is carried out having any effect on the result. For example, scheduling reads on a block device that is read-only is probably more interesting than using atomic reads (whether the read is done at time <code>T0</code> or <code>T1</code>, the result remains exactly the same).</p><h5 id="allocating-a-block-device."><a href="#allocating-a-block-device." class="anchor"></a>Allocating a block device.</h5><p>A block device is basically a file. The only constraint is that its size must be aligned. This means that if you want to launch your unikernel with a page size of 512 (the default value for Solo5), the file must have a size that is a multiple of 512. Here's how to create a block device with <code>dd</code>:</p><pre class="language-ocaml"><code>  $ dd if=/dev/urandom of=block.img count=1024 bs=512</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-bigstring"><a href="#type-bigstring" class="anchor"></a><code><span><span class="keyword">type</span> bigstring</span><span> =
  <span><span>(char, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Net"><a href="#module-Net" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Net/index.html">Net</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Block"><a href="#module-Block" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Block/index.html">Block</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Hook"><a href="#module-Hook" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Hook/index.html">Hook</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clock_monotonic"><a href="#val-clock_monotonic" class="anchor"></a><code><span><span class="keyword">val</span> clock_monotonic : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>clock_monotonic ()</code> returns monotonic time since an unspecified period in the past.</p><p>The monotonic clock corresponds to the CPU time spent since the boot time. The monotonic clock cannot be relied upon to provide accurate results - unless great care is taken to correct the possible flaws. Indeed, if the unikernel is suspended (by the host system), the monotonic clock will no longer be aligned with the &quot;real time elapsed&quot; since the boot.</p><p>This operation is <b>atomic</b>. In other words, it does not give the scheduler the opportunity to execute another task.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clock_wall"><a href="#val-clock_wall" class="anchor"></a><code><span><span class="keyword">val</span> clock_wall : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>clock_wall ()</code> returns wall clock in UTC since the UNIX epoch (1970-01-01).</p><p>The wall clock corresponds to the host's clock. Indeed, each time <code>clock_wall ()</code> is called, a syscall/hypercall is made to get the host's clock. Compared to the monotonic clock, getting the host's clock may take some time.</p><p>This operation is atomic. In other words, it does not give the scheduler the opportunity to execute another task.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sleep"><a href="#val-sleep" class="anchor"></a><code><span><span class="keyword">val</span> sleep : <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>sleep ns</code> blocks (suspends) the current task for <code>ns</code> nanoseconds.</p></div></div><h3 id="the-first-entry-point-of-an-unikernels."><a href="#the-first-entry-point-of-an-unikernels." class="anchor"></a>The first entry-point of an unikernels.</h3><p>A unikernel is an application that can require several devices. <a href="#val-net"><code>net</code></a> devices (<code>tap</code> interfaces) and <a href="#val-block"><code>block</code></a> devices (files). These devices can be acquired by name and transformed (via <a href="#val-map"><code>map</code></a>.</p><p>For example, a block device can be transformed into a file system, provided that the latter implementation uses the read and write operations associated with block devices (see <a href="Block/index.html"><code>Block</code></a>).</p><pre class="language-ocaml"><code>  let fs ~name =
    let open Mkernel in
    map [ block name ] @@ fun blk () -&gt; Fat32.of_solo5_block blk</code></pre><p>Mkernel acquires these devices, performs the transformations requested by the user and returns the results:</p><pre class="language-ocaml"><code>  let () =
    Mkernel.(run [ fs ~name:&quot;disk.img&quot; ]) @@ fun fat32 () -&gt;
    let file_txt = Fat32.openfile fat32 &quot;file.txt&quot; in
    let finally () = Fat32.close file_txt in
    Fun.protect ~finally @@ fun () -&gt;
    let line = Fat32.read_line file_txt in
    print_endline line</code></pre><p>Finally, it executes the code given by the user. The user can therefore “build-up” complex systems (such as a TCP/IP stack from a net-device, or a file system from a block-device using the <a href="#val-map"><code>map</code></a> function).</p><div class="odoc-spec"><div class="spec type anchored" id="type-arg"><a href="#type-arg" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a arg</span></span></code></div><div class="spec-doc"><p><code>'a arg</code> knows the type of an argument given to <a href="#val-run"><code>run</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-devices"><a href="#type-devices" class="anchor"></a><code><span><span class="keyword">type</span> <span>('k, 'res) devices</span></span><span> = </span></code><ol><li id="type-devices.[]" class="def variant constructor anchored"><a href="#type-devices.[]" class="anchor"></a><code><span>| </span><span><span class="constructor">[]</span> : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'res</span>, <span class="type-var">'res</span>)</span> <a href="#type-devices">devices</a></span></span></code></li><li id="type-devices.::" class="def variant constructor anchored"><a href="#type-devices.::" class="anchor"></a><code><span>| </span><span><span class="constructor">::</span> : <span><span class="type-var">'a</span> <a href="#type-arg">arg</a></span> * <span><span>(<span class="type-var">'k</span>, <span class="type-var">'res</span>)</span> <a href="#type-devices">devices</a></span> <span class="arrow">&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'k</span>, <span class="type-var">'res</span>)</span> <a href="#type-devices">devices</a></span></span></code></li></ol></div><div class="spec-doc"><p>Multiple devices are passed to <a href="#val-run"><code>run</code></a> using a list-like syntax. For instance:</p><pre class="language-ocaml"><code>  let () =
    Mkernel.(run [ block &quot;disk.img&quot; ]) @@ fun _blk () -&gt;
    print_endline &quot;Hello World!&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-net"><a href="#val-net" class="anchor"></a><code><span><span class="keyword">val</span> net : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="Net/index.html#type-t">Net.t</a> * <a href="Net/index.html#type-cfg">Net.cfg</a>)</span> <a href="#type-arg">arg</a></span></span></code></div><div class="spec-doc"><p><code>net name</code> is a net device which can be used by the <a href="Net/index.html"><code>Net</code></a> module. The given name must correspond to the argument given to the Solo5 tender or the qemu tender. For example, if the invocation of our unikernel with Solo5 corresponds to:</p><pre class="language-ocaml"><code>  $ solo5-hvt --net:service=tap0 -- unikernel.hvt</code></pre><p>The name of the block would be: <code>&quot;service&quot;</code>.</p><p>The user can specify the MAC address of the virtual interface the user wishes to use. Otherwise, Solo5 will choose a random one. It is given via the <a href="Net/index.html#type-cfg"><code>Net.cfg</code></a> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-block"><a href="#val-block" class="anchor"></a><code><span><span class="keyword">val</span> block : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Block/index.html#type-t">Block.t</a> <a href="#type-arg">arg</a></span></span></code></div><div class="spec-doc"><p><code>block name</code> is a block device which can be used by the <a href="Block/index.html"><code>Block</code></a> module. The given name must correspond to the argument given to the Solo5 tender or the qemu tender. For example, if the invocation of our unikernel with Solo5 corresponds to:</p><pre class="language-ocaml"><code>  $ solo5-hvt --block:disk=file.txt -- unikernel.hvt</code></pre><p>The name of the block would be: <code>&quot;disk&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span class="type-var">'f</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'f</span>, <span class="type-var">'a</span>)</span> <a href="#type-devices">devices</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-arg">arg</a></span></span></code></div><div class="spec-doc"><p><code>map fn devices</code> provides a means for creating devices using other <code>devices</code>. For example, one might use a TCP/IP stack from a <a href="#val-net"><code>net</code></a> device:</p><pre class="language-ocaml"><code>  let tcpip ~name : Tcpip.t Mkernel.arg =
    Mkernel.(map [ net name ]) @@ fun ((net : Mkernel.Net.t), cfg) () -&gt;
    Tcpip.of_net_device net</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-arg">arg</a></span></span></code></div><div class="spec-doc"><p><code>const v</code> always returns <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?now</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?g</span>:<a href="../../../stdlib/Stdlib/Random/State/index.html#type-t">Random.State.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-devices">devices</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>The first entry-point of an unikernel with Solo5 and Miou.</p></div></div></div></body></html>
