<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Block (docs.local.mkernel.Mkernel.Block)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">docs</a> &#x00BB; <a href="../../../index.html">local</a> &#x00BB; <a href="../../index.html">mkernel</a> &#x00BB; <a href="../index.html">Mkernel</a> &#x00BB; Block</nav><header class="odoc-preamble"><h1>Module <code><span>Mkernel.Block</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#scheduled-operations-on-block-devices.">Scheduled operations on block-devices.</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of block devices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pagesize"><a href="#val-pagesize" class="anchor"></a><code><span><span class="keyword">val</span> pagesize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pagesize t</code> returns the number of bytes in a memory page, where &quot;page&quot; is a fixed length block, the unit for memory allocation and block-device mapping performed by the functions above.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length t</code> returns the length of the block device (in bytes).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atomic_read"><a href="#val-atomic_read" class="anchor"></a><code><span><span class="keyword">val</span> atomic_read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>atomic_read t ~src_off ?dst_off bstr</code> reads data of <code>pagesize t</code> bytes into the buffer <code>bstr</code> (starting at byte <code>dst_off</code>) from the block device <code>t</code> at byte <code>src_off</code>. Always reads the full amount of <code>pagesize t</code> bytes (&quot;short reads&quot; are not possible).</p><p>This operation is called <b>atomic</b>, meaning that it is indivisible and irreducible. What's more, Miou can't do anything else (such as execute other tasks) until this operation has been completed.</p><p>The advantage of this type of operation is that you can assume a precise state, not only of the memory but also of the block-device, which cannot change during the read.</p><p>The disadvantage is that this operation can take a long time (and make your unikernel unavailable to all events for the duration of the operation) depending on the file system used by the host and the hardware used to store the block-device.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_off</code> is not a multiple of <code>pagesize t</code> or if the length of <code>bstr</code> is not equal to <code>pagesize t</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atomic_write"><a href="#val-atomic_write" class="anchor"></a><code><span><span class="keyword">val</span> atomic_write : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>atomic_write t ~src_off ?dst_off bstr</code> writes data <code>pagesize t</code> bytes from the buffer <code>bstr</code> (at byte <code>dst_off</code>) to the block device identified by <code>t</code>, starting at byte <code>src_off</code>. Data is either written in it's entirety or not at all (&quot;short writes&quot; are not possible).</p><p>This operation is called <b>atomic</b>, meaning that it is indivisible and irreducible. What's more, Miou can't do anything else (such as execute other tasks) until this operation has been completed.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>dst_off</code> is not a multiple of <code>pagesize t</code> or if the length of <code>bstr</code> is not equal to <code>pagesize t</code>.</p></li></ul></div></div><h4 id="scheduled-operations-on-block-devices."><a href="#scheduled-operations-on-block-devices." class="anchor"></a>Scheduled operations on block-devices.</h4><p>As far as operations on scheduled block-devices are concerned, here's a description of when Miou performs these operations.</p><p>As soon as Miou tries to observe possible events (such as the reception of a packet - see <code>Net.read</code>), it also performs a (single) block-device operation. If Miou still has time (such as waiting for the end of a <a href="../index.html#val-sleep"><code>sleep</code></a>), it can perform several operations on the block-devices until it runs out of time.</p><p>In short, operations on scheduled block-devices have the lowest priority. A unikernel can't go faster than the operations on waiting block-devices, so it's said to be I/O-bound on block-devices.</p><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-atomic_read"><code>atomic_read</code></a>, but the operation is scheduled. That is, it's not actually done, but will be as soon as Miou gets the chance.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-atomic_write"><code>atomic_write</code></a>, but the operation is scheduled. That is, it's not actually done, but will be as soon as Miou gets the chance.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <a href="../../../../stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>connect name</code> returns a block device according to the given <code>name</code>. It must correspond to the name given as an argument to the Solo5 tender. For example, if the invocation of our unikernel with Solo5 corresponds to:</p><pre class="language-ocaml"><code>  $ solo5-hvt --block:disk=file.txt -- unikernel.hvt</code></pre><p>The name of the block would be: <code>&quot;disk&quot;</code>.</p></div></div></div></body></html>
