<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Net (docs.local.mkernel.Mkernel.Net)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">docs</a> &#x00BB; <a href="../../../index.html">local</a> &#x00BB; <a href="../../index.html">mkernel</a> &#x00BB; <a href="../index.html">Mkernel</a> &#x00BB; Net</nav><header class="odoc-preamble"><h1>Module <code><span>Mkernel.Net</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#writing-to-a-net-device-according-to-the-backend.">Writing to a net device according to the backend.</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of network interfaces.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mac"><a href="#type-mac" class="anchor"></a><code><span><span class="keyword">type</span> mac</span><span> = <span class="keyword">private</span> string</span></code></div><div class="spec-doc"><p>The type of the hardware addres (MAC) of an ethernet interface.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cfg"><a href="#type-cfg" class="anchor"></a><code><span><span class="keyword">type</span> cfg</span><span> = </span><span>{</span></code><ol><li id="type-cfg.mac" class="def record field anchored"><a href="#type-cfg.mac" class="anchor"></a><code><span>mac : <a href="#type-mac">mac</a>;</span></code></li><li id="type-cfg.mtu" class="def record field anchored"><a href="#type-cfg.mtu" class="anchor"></a><code><span>mtu : int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_bigstring"><a href="#val-read_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> read_bigstring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>read_bigstring t ?off ?len bstr</code> reads <code>len</code> (defaults to <code>Bigarray.Array1.dim bstr - off</code>) bytes from the net device <code>t</code>, storing them in byte sequence <code>bstr</code>, starting at position <code>off</code> (defaults to <code>0</code>) in <code>bstr</code>. Return the number of bytes actually read.</p><p><code>read_bigstring</code> attempts an initial read. If it fails, we give the scheduler the opportunity to execute another task. The current task will be resumed as soon as bytes are available in the given net-device <code>t</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>bstr</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_bytes"><a href="#val-read_bytes" class="anchor"></a><code><span><span class="keyword">val</span> read_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>read_bytes</code> is <a href="#val-read_bigstring"><code>read_bigstring</code></a> but for <code>bytes</code>. However, this function uses an internal buffer (of a fixed size) which transmits the bytes from the net-device to the <code>byte</code> given by the user. If the <code>byte</code> given by the user is larger than the internal buffer, several actual reads are made.</p><p>This means that a single <code>read_bytes</code> can give the scheduler several opportunities to execute other tasks.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>bstr</code>.</p></li></ul></div></div><h5 id="writing-to-a-net-device-according-to-the-backend."><a href="#writing-to-a-net-device-according-to-the-backend." class="anchor"></a>Writing to a net device according to the backend.</h5><p>Depending on the backend used (Solo5/hvt or Unikraft &amp; Solo5/virtio), writing to a TAP interface may involve an intermediate &quot;queue&quot; between the unikernel (which fills this queue) and the tender (which consumes this queue). This feature allows for a process on the tender side that attempts to write without interruption (and thus improves performance).</p><p>In this case, unlike Solo5/hvt, writing is not necessarily effective between the unikernel and the TAP interface. However, this effectiveness also involves the tender's point of view, which is not taken into account (deliberately) in this documentation.</p><p>Furthermore, from the point of view of the unikernel, OCaml and Miou (and only on that side), the write is effective.</p><div class="odoc-spec"><div class="spec value anchored" id="val-write_bigstring"><a href="#val-write_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> write_bigstring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_bigstring t ?off ?len bstr</code> writes <code>len</code> (defaults to <code>Bigarray.Array1.dim bstr - off</code>) bytes to the net device <code>t</code>, taking them from byte sequence <code>bstr</code>, starting at position <code>off</code> (defaults to <code>0</code>) in <code>bstr</code>.</p><p><code>write_bigstring</code> is currently writing directly to the net device <code>t</code>. In other words, the write is effective and does not give the scheduler the opportunity to execute another task during the write. It is therefore an atomic operation. Writing cannot fail.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../../stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>bstr</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span><span class="keyword">val</span> write_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-write_bigstring"><code>write_bigstring</code></a>, but for <code>string</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_into"><a href="#val-write_into" class="anchor"></a><code><span><span class="keyword">val</span> write_into : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">fn</span>:<span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Depending on the backend used, an underlying allocation may be performed to write a new Ethernet frame. In the case of Unikraft, for example, we need to allocate a buffer that will be added to Unikraft's internal queue so that it can be written to the TAP interface. The same applies to Solo5 and its <i>virtio</i> support.</p><p><code>write_into</code> has the same characteristic as <a href="#val-write_bigstring"><code>write_bigstring</code></a>, i.e. it is an atomic operation that does not give the scheduler the opportunity to execute another task.</p><p>In this specific case, <code>write_into</code> is more useful than <a href="#val-write_bigstring"><code>write_bigstring</code></a> because it prepares the allocation and lets the user write to the allocated buffer via the given <code>fn</code> function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * <a href="#type-cfg">cfg</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <a href="../../../../stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>connect name</code> returns a net device according to the given <code>name</code>. It must correspond to the name given as an argument to the Solo5 tender. For example, if the invocation of our unikernel with Solo5 corresponds to:</p><pre class="language-ocaml"><code>  $ solo5-hvt --net:service=tap0 -- unikernel.hvt</code></pre><p>The name of the block would be: <code>&quot;service&quot;</code>.</p></div></div></div></body></html>
